

import threading
import time
import re
import os
#import numpy as np


from new_model_env import task_select_core_35_task,task_select_core , task_select_core_30_task,task_select_core_5_task,task_select_core_25_task



def get_nomalize_core_stress_and_temprerature_stress(app,core,task_num): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
    state =[]
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    T1= get_Tem()
    #run_time=task_select_core(app,core)
    run_time=task_select_core_30_task(app,core,task_num)
    #run_time = task_select_core_25_task(app, core)
    #run_time=task_select_core_5_task(app,core)
    T2 = get_Tem()
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    freq = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(round(float(message[i+2])/3600,3))  #2700 = max_freq
    for i in range(len(freq)):
        state.append(round(util[i]*0.3 + freq[i]*0.7,3))
    for i in range(len(T1)):
        state.append(round((T2[i]+(T2[i]-T1[i])) / 91,3))
    """
      1.获取运行频率并进行归一化，获取利用率，使用7:3的比例进行加权求和
      2.获取瞬时任务和任务的变化量，求温度压力并进行归一化处理
      3.使用负载信息和温度信息来反应系统状态
      1. Get the running frequency and normalize it, get the utilization rate, and use the proportion of 7:3 for weighted summation
      2. Obtain the instantaneous task and task change, calculate the temperature and pressure and normalize it
      3. Use load information and temperature information to reflect system status
      
        """


    num_feature=[0.131,0.131,0.131,0.131,0.131, 1,1,1,1,1, 0.106,0.106,0.106,0.106,0.106, 0.431,0.431,0.431,0.431,0.431,0.516,0.516,0.516,0.516,0.516,0.217,0.217,0.217,0.217,0.217, 0.548,0.548,0.548,0.548,0.548]
    num_feature1 = num_feature[0:task_num]
    """
    1.三十五个任务的特征归一化：最初使用了任务所要执行指令的总数来表示任务特征，后面发现可以使用程序对应的通过llvm编译产生的ir文件的大小来表示程序特征
    2.我们使用任务fluidanimate对应的ir文件大小310.1kb来归一化七个程序的内在特征（七个任务中fluidanimate的ir文件最大）
    1.Thirty five task characteristics normalization: initially,
     the total number of instructions to be executed by the task is used to represent the task characteristics. Later,
      it is found that the size of the IR file generated by llvm compilation can be used to represent the program characteristics
    2.We use the IR file size 310.1kb corresponding to task fluidanimate to normalize the intrinsic characteristics of the seven programs 
     (the IR file size of fluidanimate is the largest among the seven tasks)
    """
    # nom_feature = [0.143, 0.143, 0.143, 0.143, 0.143, 1.0, 1.0, 1.0, 1.0, 1.0, 0.078, 0.078, 0.078, 0.078, 0.078, 0.402, 0.402, 0.402,
    #  0.402, 0.402, 0.485, 0.485, 0.485, 0.485, 0.485, 0.214, 0.214, 0.214, 0.214, 0.214, 0.425, 0.425, 0.425, 0.425,
    #  0.425]
    all_task_input = [0.0019, 0.0025, 0.0498, 0.1923, 0.7592,
                      0.011, 0.0428, 0.0985, 0.2505, 0.696,
                      0.0002, 0.0012,0.1436, 0.2885, 0.5693,
                      0.2, 0.26, 0.32, 0.38, 0.44,
                      0.2, 0.4, 0.6, 0.8, 1,  #输入不一致但是输入数据量一致  The input is inconsistent, but the amount of input data is consistent
                      0.0134,0.0174, 0.3324, 0.3365, 0.3405,
                      0.0002, 0.0003, 0.0479, 0.1907, 0.7616]
    all_task_input1=all_task_input[0:task_num]
    """
      对输入进行归一化，对于输入大小不一致的程序直接使用文件大小归一化，对于输入一致的程序我们按输入的排序进行归一化
      The input is normalized. For the program with inconsistent input size, file size normalization is used directly. 
      For the program with consistent input, we normalize it according to the order of input
      """
    state.append(all_task_input1[app])
    state.append(num_feature1[app])
    # nom_feature = [0.143, 0.143, 0.143, 0.143, 0.143, 1.0, 1.0, 1.0, 1.0, 1.0, 0.078, 0.078, 0.078, 0.078, 0.078, 0.402, 0.402, 0.402,
    #  0.402, 0.402, 0.485, 0.485, 0.485, 0.485, 0.485, 0.214, 0.214, 0.214, 0.214, 0.214, 0.425, 0.425, 0.425, 0.425,
    #  0.425]
    # all_task_input = [0.0019, 0.0025, 0.0498, 0.1923, 0.7592, 0.011, 0.0428, 0.0985, 0.2505, 0.696, 0.0002, 0.0012,
    #                       0.1436, 0.2885, 0.5693, 0.2, 0.26, 0.32, 0.38, 0.44, 0.1, 0.15, 0.2, 0.25, 0.3, 0.0134,
    #                       0.0174, 0.3324, 0.3365, 0.3405, 0.0002, 0.0003, 0.0479, 0.1907, 0.7616]
    # state.append(all_task_input[app])
    #state.append(nom_feature[app])

    return run_time, state,T2   #返回任务的运行时间，状态，任务运行结束时所有内核的温度

class MyThread(threading.Thread):
    def __init__(self, func, args, name=''):
        threading.Thread.__init__(self)
        self.name = name
        self.func = func
        self.args = args
        self.result = self.func(*self.args)

    def get_result(self):
        try:
            return self.result
        except Exception:
            return None


def one():
    time.sleep(5)
    print('one', '111')


def two(i):
    a = i + 3
    print('two', a)
    return a

def _read_cpu_usage():
    """Read the current system cpu usage from /proc/stat"""
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print( "ERROR: Can not open %s,The system cannot continue to run" , statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    return cpulist


def get_nomalize_freq_util(list1): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    sleep = 0.5
    time.sleep(sleep)
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
        #list1.append(float(cpuper))
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    # print(message)
    freq = []
    #print(freq,util)
    nomalize_freq_util = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(float(message[i+2])/3600)  #2700 = max_freq
    for i in range(len(freq)):
        #nomalize_freq_util.append(util[i]*0.7 + freq[i]*0.3)
        list1.append(round(util[i]*0.7 + freq[i]*0.3,3))
    #print(freq, util)

    #return nomalize_freq_util

def get_Tem():
    cmdline = "sensors"
    #os.system("sensors")
    var = os.popen(cmdline).read()
    #s =
    s1=[]
    s2=[]
    message = var.split()
    for i in range(len(message)):
        if message[i]=="Core":
            s1.append(float(re.findall("\d+", message[i + 2])[0].split()[0]))  # 取
            s1.append(float(re.findall("\d+", message[i + 2])[0].split()[0]))  # 取
    return s1
#print(get_Tem())
def get_tem_and_temgradient(list2): # t = (T1 + (T1 - T2))/ 80
    T1 = get_Tem()
    time.sleep(0.8)
    T2 = get_Tem()
    T3 = []
    for i in range(len(T1)):
        #T3.append((T2[i] + (T2[i] - T1[i]))/90)
        list2.append( round((T2[i] + (T2[i] - T1[i]))/90,3) )
    #print(T1,T2)
    # list.append()
    # return T3

def get_result(list2):
    threads = []  # 定义一个线程池
    #a = get_tem_and_temgradient(0.4)
    t = MyThread(get_nomalize_freq_util, (list2,), get_nomalize_freq_util.__name__)
    t2 = MyThread(get_tem_and_temgradient, (list2,), get_tem_and_temgradient.__name__)
    #t2 = threading.Thread(target=t2)  # 建立一个线程并且赋给t1，这个线程指定调用方法one，并且不带参数
    threads.append(t)  # 把t1线程装到threads线程池里
    threads.append(t2)
    for i in threads:
        i.start()

    for i in range(len(threads)):  # jion()方法等待线程完成
        threads[i].join()
    # # t.start()
    # t2.start()
    #b = threads[0].get_result()
    #print('result', b)
    #a = threads[1].get_result()
    #return list2

# def main():
#     threads = []  # 定义一个线程池
#     list2 = []
#     list1 = []
#     threads.append(threading.Thread(target=get_tem_and_temgradient,name="t_gt"))
#     threads.append((threading.Thread(target=get_nomalize_freq_util,name="f_u")))
#     #a = get_tem_and_temgradient(0.4)
#     # t = MyThread(get_nomalize_freq_util, (list2,), get_nomalize_freq_util.__name__)
#     # t2 = MyThread(get_tem_and_temgradient, (list2,), get_tem_and_temgradient.__name__)
#     # #t2 = threading.Thread(target=t2)  # 建立一个线程并且赋给t1，这个线程指定调用方法one，并且不带参数
#     # threads.append(t)  # 把t1线程装到threads线程池里
#     # threads.append(t2)
#     for i in threads:
#         i.start()
#     #
#     # for i in range(len(threads)):  # jion()方法等待线程完成
    #     threads[i].join()
    # # t.start()
    # t2.start()
    #b = threads[0].get_result()
    #print('result', b)
    #a = threads[1].get_result()
    #return list2
# list2 = []
def get_nom_state(list2):
    threads = []  # 定义一个线程池,多线程并行读取系统状态：温度，温度梯度，频率，利用率
    threads.append(threading.Thread(target=get_tem_and_temgradient, args=(list2,), name="t_gt"))
    threads.append((threading.Thread(target=get_nomalize_freq_util, args=(list2,), name="f_u")))
    for i in threads:
        i.start()
    for i in threads:
        i.join()


def get_nom_state_init(list2):
    threads = []  # 定义一个线程池,多线程并行读取系统状态：温度，温度梯度，频率，利用率
    threads.append(threading.Thread(target=get_tem_and_temgradient, args=(list2,), name="t_gt"))
    threads.append((threading.Thread(target=get_nomalize_freq_util, args=(list2,), name="f_u")))
    for i in threads:
        i.start()
    for i in threads:
        i.join()
    num_feature = [0.131, 0.131, 0.131, 0.131, 0.131, 1, 1, 1, 1, 1, 0.106, 0.106, 0.106, 0.106, 0.106, 0.431,
                       0.431, 0.431, 0.431, 0.431, 0.516, 0.516, 0.516, 0.516, 0.516, 0.217, 0.217, 0.217, 0.217, 0.217,
                       0.548, 0.548, 0.548, 0.548, 0.548]
    """
        1.三十五个任务的特征归一化：最初使用了任务所要执行指令的总数来表示任务特征，后面发现可以使用程序对应的通过llvm编译产生的ir文件的大小来表示程序特征
        2.我们使用任务fluidanimate对应的ir文件大小310.1kb来归一化七个程序的内在特征（七个任务中fluidanimate的ir文件最大）
        1.Thirty five task characteristics normalization: initially,
         the total number of instructions to be executed by the task is used to represent the task characteristics. Later,
          it is found that the size of the IR file generated by llvm compilation can be used to represent the program characteristics
        2.We use the IR file size 310.1kb corresponding to task fluidanimate to normalize the intrinsic characteristics of the seven programs 
         (the IR file size of fluidanimate is the largest among the seven tasks)
        """
        # nom_feature = [0.143, 0.143, 0.143, 0.143, 0.143, 1.0, 1.0, 1.0, 1.0, 1.0, 0.078, 0.078, 0.078, 0.078, 0.078, 0.402, 0.402, 0.402,
        #  0.402, 0.402, 0.485, 0.485, 0.485, 0.485, 0.485, 0.214, 0.214, 0.214, 0.214, 0.214, 0.425, 0.425, 0.425, 0.425,
        #  0.425]
    all_task_input = [0.0019, 0.0025, 0.0498, 0.1923, 0.7592,
                          0.011, 0.0428, 0.0985, 0.2505, 0.696,
                          0.0002, 0.0012, 0.1436, 0.2885, 0.5693,
                          0.2, 0.26, 0.32, 0.38, 0.44,
                          0.2, 0.4, 0.6, 0.8, 1,
                          # 输入不一致但是输入数据量一致  The input is inconsistent, but the amount of input data is consistent
                          0.0134, 0.0174, 0.3324, 0.3365, 0.3405,
                          0.0002, 0.0003, 0.0479, 0.1907, 0.7616]

    """
          对输入进行归一化，对于输入大小不一致的程序直接使用文件大小归一化，对于输入一致的程序我们按输入的排序进行归一化
          The input is normalized. For the program with inconsistent input size, file size normalization is used directly. 
          For the program with consistent input, we normalize it according to the order of input
          """
    list2.append( all_task_input[0])
    list2.append(num_feature[0])



def get_nom_state5(list2):
    threads = []  # 定义一个线程池,多线程并行读取系统状态：温度，温度梯度，频率，利用率
    threads.append(threading.Thread(target=get_tem_and_temgradient, args=(list2,), name="t_gt"))
    threads.append((threading.Thread(target=get_nomalize_freq_util, args=(list2,), name="f_u")))
    for i in threads:
        i.start()
    for i in threads:
        i.join()







def get_nomalize_core_stress_and_temprerature_stress1(app,core): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    tt2=time.time()
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
    state =[]
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    T1= get_Tem()
    tt2=time.time()-tt2
    #run_time=task_select_core(app,core)
    run_time=task_select_core_35_task(app,core)
    ttt1=time.time()
    T2 = get_Tem()
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
        #list1.append(float(cpuper))
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    # print(message)
    freq = []

    #print(freq,util)
    ttt1=time.time()
    nomalize_freq_util = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(round(float(message[i+2])/3600,3))  #2700 = max_freq
    for i in range(len(freq)):
        #nomalize_freq_util.append(util[i]*0.7 + freq[i]*0.3)
        state.append(round(util[i]*0.3 + freq[i]*0.7,3))
    for i in range(len(T1)):
        state.append(round((T2[i]+(T2[i]-T1[i])) / 91,3))
    print("time-ttt",time.time()-ttt1)
    #九任务frature and input
    # list_freature = [0.065, 0.065,0.065, 0.183, 0.183, 0.183, 0.098,0.098,0.098,0.065]
    # list_input_dfferent_three_task_thrid = [0.049, 0.191, 0.760, 0.31, 0.33, 0.36, 0.31, 0.33, 0.36, 0.049]
    # state.append(list_input_dfferent_three_task_thrid[app])
    # state.append(list_freature[app])

    #25 任务下的feature and input

    nom_feature = [0.143, 0.143, 0.143, 0.143, 0.143, 1.0, 1.0, 1.0, 1.0, 1.0, 0.078, 0.078, 0.078, 0.078, 0.078, 0.402, 0.402, 0.402,
     0.402, 0.402, 0.485, 0.485, 0.485, 0.485, 0.485, 0.214, 0.214, 0.214, 0.214, 0.214, 0.425, 0.425, 0.425, 0.425,
     0.425]
    all_task_input = [0.0019, 0.0025, 0.0498, 0.1923, 0.7592, 0.011, 0.0428, 0.0985, 0.2505, 0.696, 0.0002, 0.0012,
                          0.1436, 0.2885, 0.5693, 0.2, 0.26, 0.32, 0.38, 0.44, 0.1, 0.15, 0.2, 0.25, 0.3, 0.0134,
                          0.0174, 0.3324, 0.3365, 0.3405, 0.0002, 0.0003, 0.0479, 0.1907, 0.7616]
    #
    state.append(all_task_input[app])
    state.append(nom_feature[app])
    ttt1=time.time()-ttt1
    return run_time, state,T2,util,ttt1


def get_nomalize_core_stress_and_temprerature_stress2(app,core): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
    state =[]
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    T1= get_Tem()
    #run_time=task_select_core(app,core)
    run_time=task_select_core_35_task(app,core)
    T2 = get_Tem()
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
        #list1.append(float(cpuper))
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    # print(message)
    freq = []

    #print(freq,util)
    nomalize_freq_util = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(round(float(message[i+2])/3600,3))  #2700 = max_freq
    for i in range(len(freq)):
        #nomalize_freq_util.append(util[i]*0.7 + freq[i]*0.3)
        state.append(round(util[i]*0.7 + freq[i]*0.3,3))
    for i in range(len(T1)):
        state.append(round((T2[i]+(T2[i]-T1[i])) / 91,3))

    #九任务frature and input
    # list_freature = [0.065, 0.065,0.065, 0.183, 0.183, 0.183, 0.098,0.098,0.098,0.065]
    # list_input_dfferent_three_task_thrid = [0.049, 0.191, 0.760, 0.31, 0.33, 0.36, 0.31, 0.33, 0.36, 0.049]
    # state.append(list_input_dfferent_three_task_thrid[app])
    # state.append(list_freature[app])

    #25 任务下的feature and input

    nom_feature = [0.143, 0.143, 0.143, 0.143, 0.143, 1.0, 1.0, 1.0, 1.0, 1.0, 0.078, 0.078, 0.078, 0.078, 0.078, 0.402, 0.402, 0.402,
     0.402, 0.402, 0.485, 0.485, 0.485, 0.485, 0.485, 0.214, 0.214, 0.214, 0.214, 0.214, 0.425, 0.425, 0.425, 0.425,
     0.425]
    all_task_input = [0.0019, 0.0025, 0.0498, 0.1923, 0.7592, 0.011, 0.0428, 0.0985, 0.2505, 0.696, 0.0002, 0.0012,
                          0.1436, 0.2885, 0.5693, 0.2, 0.26, 0.32, 0.38, 0.44, 0.1, 0.15, 0.2, 0.25, 0.3, 0.0134,
                          0.0174, 0.3324, 0.3365, 0.3405, 0.0002, 0.0003, 0.0479, 0.1907, 0.7616]

    state.append(all_task_input[app])
    state.append(nom_feature[app])
    return run_time, state,T2

def get_nomalize_ubuntu_state(app,action): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
   # t=threading.Thread(target=task_select_core1,args=(app,action))
   # t.start()
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    sleep = 0.8
    T1 = get_Tem()
   # time.sleep(sleep)
   # run_time = task_select_core1(app, action)
    #threads = []
   # threads.append(MyThread(task_select_core1,(app,action)))
   # for i in threads:
    #    i.start()
    t = threading.Thread(target=task_select_core,args=(app,action))
   # t = MyThread(task_select_core1,(app,action),task_select_core1.__name__)
    t.start()
    time.sleep(0.5)
    T2 = get_Tem()
   # task_select_core1(app,action)
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
        #list1.append(float(cpuper))
    # T2 = get_Tem1()
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    # print(message)
    freq = []
    state = []
    #print(freq,util)
    nomalize_freq_util = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(float(message[i+2])/2200)  #2700 = max_freq
    for i in range(int(len(freq)/2)):
        nomalize_freq_util.append(util[i]*0.7 + freq[i]*0.3)
        state.append(round(util[i]*0.7 + freq[i]*0.3,3))
    for i in range(len(T1)):
        state.append( round((T2[i] + (T2[i] - T1[i]))/90,3) )
    #print(freq, util)

    return state,T2

from new_model_env import task_select_core1

def get_nomalize_ubuntu_state2(app,core): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
   # t=threading.Thread(target=task_select_core1,args=(app,action))
   # t.start()
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    sleep = 0.8
    T1 = get_Tem()
   # time.sleep(sleep)
   # run_time = task_select_core1(app, action)
    #threads = []
   # threads.append(MyThread(task_select_core1,(app,action)))
   # for i in threads:
    #    i.start()
    t = threading.Thread(target=task_select_core1,args=(app,core))
   # # t = MyThread(task_select_core1,(app,action),task_select_core1.__name__)
    t.start()
    time.sleep(2)
    T2 = get_Tem()
   # task_select_core1(app,action)
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
        #list1.append(float(cpuper))
    # T2 = get_Tem1()
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    # print(message)
    freq = []
    state = []
    #print(freq,util)
    nomalize_freq_util = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(float(message[i+2])/2200)  #2700 = max_freq
    print("freq",freq)
    for i in range(int(len(freq))):
        nomalize_freq_util.append(util[i]*0.7 + freq[i]*0.3)
        state.append(round(util[i]*0.7 + freq[i]*0.3,3))
    for i in range(len(T1)):
        state.append( round((T2[i] + (T2[i] - T1[i]))/90,3) )
    #print(freq, util)

    return state,T2

#print("init",get_nomalize_ubuntu_state2())

def get_nomalize_core_stress_and_temprerature_stress3(app,core): #获取sleep时间间隔内的标准化后的频率和利用率的加权值  系统压力值 ：freq * 0.3 + util * 0.7
    cpuusage = {}
    cpustart = {}
    cpuend = {}
    util = []
    state =[]
    statfile = "/proc/stat"
    cpulist = []
    try:
        f = open(statfile, 'r')
        lines = f.readlines()
    except:
        print("ERROR: Can not open %s,The system cannot continue to run", statfile)
        return []
    for line in lines:
        tmplist = line.split()
        if len(tmplist) < 5:
            continue
        for b in tmplist:
            m = re.search(r'cpu\d+', b)
            if m is not None:
                cpulist.append(tmplist)
    f.close()
    linestart = cpulist
    if not linestart:
        return 0
    for cpustr in linestart:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn =float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpustart[cpustr[0]] = str(usni) + ":" + str(usn)
    T1= get_Tem()
    #run_time=task_select_core(app,core)
    run_time= task_select_core_35_task(app,core)
    T2 = get_Tem()
    lineend = _read_cpu_usage()
    if not lineend:
        return 0
    for cpustr in lineend:
        usni = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3]) + float(cpustr[5]) + float(cpustr[6]) + float(
            cpustr[7]) + float(cpustr[4])
        usn = float(cpustr[1]) + float(cpustr[2]) + float(cpustr[3])
        cpuend[cpustr[0]] = str(usni) + ":" + str(usn)
    for line in cpustart:
        start = cpustart[line].split(':')
        usni1, usn1 = float(start[0]), float(start[1])
        end = cpuend[line].split(':')
        usni2, usn2 = float(end[0]), float(end[1])
        cpuper = (usn2 - usn1) / (usni2 - usni1)
        cpuusage[line] = float(100 * cpuper)
        util.append(float( cpuper))
        #list1.append(float(cpuper))
    cmdline=" cat /proc/cpuinfo"
    var = os.popen(cmdline).read()
    message = var.split()
    # print(message)
    freq = []
    #print(freq,util)
    nomalize_freq_util = []
    for i in range(len(message)):
        if message[i]=="MHz":
            freq.append(round(float(message[i+2])/3600,3))  #2700 = max_freq
    for i in range(len(freq)):
        #nomalize_freq_util.append(util[i]*0.7 + freq[i]*0.3)
        state.append(round(util[i]*0.7 + freq[i]*0.3,3))
    for i in range(len(T1)):
        state.append(round((T2[i]+(T2[i]-T1[i])) / 91,3))

    return run_time, state,T2,freq,util

# get_nom_state(list2)
# print(list2)
# # if __name__ == "__main__":
#     # a = 1
#     threads = []  # 定义一个线程池,多线程并行读取系统状态：温度，温度梯度，频率，利用率
#     list2 = []
#     t1 = time.time()
#     threads.append(threading.Thread(target=get_tem_and_temgradient,args=(list2,),name="t_gt"))
#     threads.append((threading.Thread(target=get_nomalize_freq_util,args=(list2,),name="f_u")))
#     t2 = time.time()
#     #a = get_tem_and_temgradient(0.4)
#     # t = MyThread(get_nomalize_freq_util, (list2,), get_nomalize_freq_util.__name__)
#     # t2 = MyThread(get_tem_and_temgradient, (list2,), get_tem_and_temgradient.__name__)
#     # #t2 = threading.Thread(target=t2)  # 建立一个线程并且赋给t1，这个线程指定调用方法one，并且不带参数
#     # threads.append(t)  # 把t1线程装到threads线程池里
#     # threads.append(t2)
#     for i in threads:
#         i.start()
#     for i in threads:
#         i.join()
#     # t1=time.time()
#     # get_result(list2)
#     # t2=time.time()
#     print('b result', list2,t2-t1)
    #
    # t1=time.time()
    # b = get_nomalize_freq_util(0.4)
    # a=get_tem_and_temgradient(0.4)
    # t2=time.time()
    # print('b result', b,a,t2-t1)
#
#
#
# from multiprocessing import Process
#
# def method1():
#     print "in method1"
#     print "in method1"
#
# def method2():
#     print "in method2"
#     print "in method2"
#
# p1 = Process(target=method1) # create a process object p1
# p1.start()                   # starts the process p1
# p2 = Process(target=method2)
# p2.start()